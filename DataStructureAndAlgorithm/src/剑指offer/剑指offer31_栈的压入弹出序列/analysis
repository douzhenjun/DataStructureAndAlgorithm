判断一个序列是否是另一个序列的出栈序列.
比如对于序列[1, 2, 3, 4, 5]和[3, 4, 5, 1, 2], 判断后者是不是前者的出栈序列, 那我们就模拟
序列1入栈的过程, 新建一个辅助栈, 遍历序列1, 将1入栈;
这时遍历序列2, 比较栈顶元素是否和序列2遍历到的元素相等, 如果相等, 那么栈顶元素出栈, 序列2继续往下遍历.
这里栈顶元素为1, 序列2遍历到的元素为3, 1 != 3, 于是序列1中元素继续入栈;
每入栈一个元素, 都比较一次栈顶元素和序列2遍历到的元素, 栈顶元素2 != 3, 继续序列1入栈
栈顶元素3 = 序列2元素3, 这时可以出栈了, 3出栈, 继续判断栈顶元素和序列2的下一个元素是否相等.
因为2 != 4, 所以继续入栈序列1, 序列1中4入栈, 和序列2中4比较, 相等, 4出栈.
栈顶元素2 != 5, 继续入栈, 5, 和序列2中元素匹配, 于是出栈5.
栈顶元素2 != 1, 并且序列1无元素入栈(遍历完了), 这个时候表明序列2不是序列1的出栈序列.
有以下几种情况:
a.当序列1遍历完成时, 栈中尚有元素, 这时如果栈顶元素和序列2中元素不相等, 将无法继续, 命题为假.
b.当序列1遍历完成时, 栈为空, 或者栈中尚有元素, 但每次栈顶元素都和序列2中元素相等, 直到栈为空, 命题为真.
c.当序列2遍历完成时, 栈中尚有元素, 这种情况不可能, 除非序列2长度超过序列1, 但这显然直接否定了命题. 我们假设序列2长度等于序列1,
因为序列2遍历下一个的条件是有元素出栈, 而出栈的前提是序列1有元素入栈, 且序列2.length == 序列1.length, 
所以可以推断序列2遍历完了,序列1一定遍历完了, 并且栈为空;